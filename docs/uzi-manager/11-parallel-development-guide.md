# 並列開発ガイド

## タスク並列化の判断基準

### 並列処理の積極的な活用

**原則：並列可能なタスクは必ず並列化する**

#### 並列化すべきタスク
1. **独立したモジュール**
   - 相互に依存しないコンポーネント（UI、ロジック、データ層）
   - 異なるファイルへの実装
   - 別々のテストファイル作成

2. **同一インターフェースの複数実装**
   - 複数のエンティティクラス（Ball, Paddle, Block）
   - 複数のマネージャークラス（ScoreManager, LivesManager）
   - 各種ユーティリティ関数

3. **並列可能な判断フロー**
   ```
   依存関係なし？ → Yes → 並列化
   異なるファイル？ → Yes → 並列化
   独立したテスト？ → Yes → 並列化
   ```

#### 直列処理が必須なタスク
1. **依存関係がある場合のみ**
   - インターフェース定義 → 実装
   - 基底クラス → 派生クラス
   - データ取得 → データ処理 → UI表示

### 並列化の実践例
```bash
# 良い例：3つのタスクを同時実行
./uzi prompt "Ballクラスを実装"
./uzi prompt "Paddleクラスを実装"
./uzi prompt "Blockクラスを実装"

# 悪い例：不要な直列化
./uzi prompt "Ballクラスを実装"
# 待機...
./uzi prompt "Paddleクラスを実装"
```

## 並列開発前の必須手順

### 1. インターフェース定義フェーズ

並列開発を開始する前に、**必ず**以下を実行してください：

```markdown
## インターフェース定義書

### モジュール: [モジュール名]
- エクスポート形式: `export { ClassName }`
- 公開メソッド:
  - `methodName(param: type): returnType` - 説明
  - `reset()` - 初期化メソッド（必須）
- 依存関係:
  - 依存するモジュール: [モジュール名]
  - 提供するインターフェース: [インターフェース名]
```

### 2. 統合テストの作成（テストファーストフェーズ）

```bash
# 統合テストを最初に作成
./uzi prompt "モジュール間の統合テストを作成してください。以下のインターフェースを使用します：[インターフェース定義]"
```

### 3. モジュール実装の並列化（仮実装→三角測量→一般化フェーズ）

```bash
# インターフェース定義を含めて各エージェントに指示
./uzi prompt "以下のインターフェース定義に従って[モジュール名]を実装してください：[インターフェース定義]"
```

## 並列開発の正しい流れ

```bash
# 1. インターフェース定義をエージェントに作成させる
./uzi prompt "ブロック崩しゲームのモジュール構成とインターフェース定義を作成"

# 2. 統合テストを作成
./uzi prompt "定義されたインターフェースに基づいて統合テストを作成"

# 3. 並列実装（インターフェース定義を含める）
./uzi prompt "フロントエンドを実装。インターフェース定義：[定義内容]"
./uzi prompt "ゲームロジックを実装。インターフェース定義：[定義内容]"
./uzi prompt "状態管理を実装。インターフェース定義：[定義内容]"

# 4. 段階的マージ
./uzi checkpoint agent1 "feat: フロントエンド実装"
npm test
./uzi checkpoint agent2 "feat: ゲームロジック実装"
npm test
```

## 段階的統合

```bash
# 1つずつモジュールを統合
./uzi checkpoint agent1 "feat: モジュールA実装"
npm test  # テスト実行

# 問題なければ次のモジュール
./uzi checkpoint agent2 "feat: モジュールB実装"
npm test  # 再度テスト実行
```

## 失敗例から学ぶ

### ❌ 悪い例
- インターフェース定義なしで並列開発
- 統合テストを後回し
- 一度に全モジュールをマージ

### ✅ 良い例
- 事前にインターフェース定義
- 統合テストを最初に作成
- 段階的にモジュールを統合