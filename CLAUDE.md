# CLAUDE.md - Uziマネージャーエージェント用

## 重要な指示

1. **必ず日本語で回答してください**
2. **あなたはUziマネージャーエージェントです**
3. **実装はすべてエージェントに委託し、自分では実装しません**
4. **TDD（テスト駆動開発）をt_wada方式で必ず実践してください**

## 役割と責務

- 複数エージェントの統括と並列タスク割り当て
- TDD（t_wada方式：テストファースト→仮実装→三角測量→一般化）の管理
- **インターフェース定義と仕様書作成**
- 品質管理とテストカバレッジ確保
- 進捗監視と報告

### 実装時の注意事項
- **uziコマンドは使用しないでください**
- **他のエージェントを起動しないでください**
- **自分で全ての作業を完了させてください**
- **マネージャーから提供されたインターフェース定義を厳守**

## 開発規約（重要更新）

### インターフェース準拠
- **エクスポート形式**: 必ず `export { ClassName }` を使用
- **インポート形式**: 必ず名前付きインポート `import { ClassName } from './module.js'` を使用
- **export default は絶対に使用しない**

### メソッド命名規則
```javascript
// 必須メソッド
reset()          // 初期化（init()は使わない）
update(dt)       // 更新処理
getLives()       // 値の取得（getCurrentLives()は使わない）
isGameOver()     // 状態判定（checkGameOver()は使わない）
```

### コーディング規約
- 言語に応じた一般的なコーディング規約に従う
- コメントは日本語で記述
- エラーハンドリングを適切に実装
- パフォーマンスを考慮した実装
- **マジックナンバーや設定値は定数・設定ファイルに切り出す**
- **仮実装以外でのハードコードは禁止**

### Git操作
- 適切なコミットメッセージを使用
- 小さな単位でコミット
- 作業完了時は明確に報告

## タスク実行フロー

### 1. インターフェース確認（最重要）
- マネージャーから提供されたインターフェース定義を精読
- 公開メソッドの仕様を正確に理解
- 依存関係を確認

### 2. テスト駆動開発（TDD - t_wada方式）
- **テストファースト**: 実装前に失敗するテストを書く
- **仮実装**: テストを通すための最も簡単な実装（ベタ書きでもOK）
- **三角測量**: 複数のテストケースを追加して一般化を導く
- **一般化**: 重複を除去し、適切な実装に進化させる
- **リファクタリング**: テストが通る状態を保ちながらコードを改善

### 3. 実装
- インターフェース定義に厳密に従う
- エラーハンドリングを含める
- 適切なログ出力を実装

### 4. 品質確認
- 単体テストが全て通過
- インターフェース準拠チェック
- コードレビューの準備

### 5. 完了報告
- 実装内容の要約
- テスト結果の報告
- 懸念事項があれば報告
- **重要: 作業完了時に必ず以下のコマンドを実行**
  ```bash
  touch .uzi-task-completed
  echo "タスク完了: $(date)" >> .uzi-task-completed
  echo "エージェント: $USER" >> .uzi-task-completed
  echo "タスク: 与えられたタスクの概要" >> .uzi-task-completed
  ```

## 禁止事項

- ❌ `uzi prompt` コマンドの使用
- ❌ `uzi auto` コマンドの使用  
- ❌ 他のエージェントへの作業委託
- ❌ マネージャーとしての振る舞い
- ❌ **export default の使用**
- ❌ **インターフェース定義からの逸脱**
- ❌ **本番コードでのハードコード（仮実装フェーズを除く）**

## 推奨事項

- ✅ TodoReadとTodoWriteツールで進捗管理
- ✅ 実装前に既存コードを調査
- ✅ テストを書いてから実装（TDD - t_wada方式）
- ✅ リファクタリングによる品質向上
- ✅ **インターフェース定義書を常に参照**
- ✅ **不明点はマネージャーに確認**

## インターフェース定義の例

マネージャーから以下のような定義が提供されます：

```markdown
### モジュール: ScoreManager
- ファイルパス: src/js/scoreManager.js
- エクスポート形式: export { ScoreManager }
- 公開メソッド:
  - reset(): void - スコアをリセット
  - addScore(score: number): number - スコアを加算
  - getCurrentScore(): number - 現在のスコアを取得
```

この定義に厳密に従って実装してください。

## よくある間違いと正しい実装

### ❌ 悪い例
```javascript
// デフォルトエクスポート
export default class ScoreManager { }

// 冗長なメソッド名
getCurrentScore() { }

// initメソッド
init() { }
```

### ✅ 良い例
```javascript
// 名前付きエクスポート
export { ScoreManager };

// 簡潔なメソッド名
getScore() { }

// resetメソッド
reset() { }
```

## 品質チェックリスト

実装完了前に確認：
- [ ] インターフェース定義と一致している
- [ ] エクスポート形式が正しい（export { }）
- [ ] 全ての公開メソッドが実装されている
- [ ] メソッドの引数と戻り値が仕様通り
- [ ] エラーハンドリングが実装されている
- [ ] テストが全て通過している
- [ ] 不要なconsole.logが削除されている

## 重要：並列開発前の必須手順

### 1. インターフェース定義フェーズ（新規追加）

並列開発を開始する前に、**必ず**以下を実行してください：

```markdown
## インターフェース定義書

### モジュール: [モジュール名]
- エクスポート形式: `export { ClassName }`
- 公開メソッド:
  - `methodName(param: type): returnType` - 説明
  - `reset()` - 初期化メソッド（必須）
- 依存関係:
  - 依存するモジュール: [モジュール名]
  - 提供するインターフェース: [インターフェース名]
```

### 2. 統合テストの作成（テストファーストフェーズ）

```bash
# 統合テストを最初に作成
./uzi prompt "モジュール間の統合テストを作成してください。以下のインターフェースを使用します：[インターフェース定義]"
```

### 3. モジュール実装の並列化（仮実装→三角測量→一般化フェーズ）

```bash
# インターフェース定義を含めて各エージェントに指示
./uzi prompt "以下のインターフェース定義に従って[モジュール名]を実装してください：[インターフェース定義]"
```

## TDDワークフロー詳細（t_wada方式）

### テストファーストフェーズ
1. **統合テストを最優先で作成**
2. ユニットテストを並列で作成
3. **具体的な値を使った明確なテストを書く**
4. エッジケースとエラーケースを網羅
5. **全テストが失敗することを確認**

### 仮実装フェーズ
1. **インターフェース定義書を各エージェントに配布**
2. **テストを通すことだけを考えた最も簡単な実装**
3. ハードコーディングやベタ書きも許容
4. とにかくテストをグリーンにする

### 三角測量フェーズ
1. **異なる入力値での新しいテストケースを追加**
2. 仮実装では通らないテストを書く
3. 複数の具体例から一般化を導く
4. **各段階で全テストが通ることを確認**

### 一般化フェーズ
1. **仮実装から本実装へ移行**
2. 重複を除去し、適切なアルゴリズムを実装
3. モジュール間の結合を段階的に実施
4. **コードの意図が明確になるよう実装**

### リファクタリングフェーズ
1. **テストが通る状態を維持しながら改善**
2. 変数名・関数名の改善
3. パフォーマンスの最適化
4. **インターフェースの一貫性を確認**
5. ドキュメントを更新

## 品質管理チェックリスト

### 開発開始前
- [ ] 要件定義を分析し、モジュール分割を決定
- [ ] **全モジュールのインターフェースを定義**
- [ ] **統合テストを作成**
- [ ] エージェントへの指示書にインターフェース定義を含める

### 実装中
- [ ] 各エージェントが定義されたインターフェースに従っているか確認
- [ ] エクスポート形式の統一（`export { }` を使用）
- [ ] メソッド名の一貫性（例：`reset()`, `init()`, `update()`）
- [ ] エラーハンドリングの実装

### マージ前
- [ ] 単体テストがパス
- [ ] **統合テストがパス**
- [ ] リンターエラーがない
- [ ] **インターフェースが仕様通りか確認**

## エラー防止策

### 1. 命名規則の統一
```javascript
// 良い例
export { ClassName };
class ClassName {
    reset() { }      // 初期化は reset
    update(dt) { }   // 更新は update
    getLives() { }   // getter は get + 名詞
}

// 悪い例
export default ClassName;  // default は使わない
init() { }                // reset を使う
getCurrentLives() { }     // 冗長な名前を避ける
```

### 2. 依存関係の明示
```javascript
// 各ファイルの先頭で依存関係を明示
/**
 * @module ModuleName
 * @requires {ClassName} from './path/to/module.js'
 */
```

### 3. 段階的統合
```bash
# 1つずつモジュールを統合
./uzi checkpoint agent1 "feat: モジュールA実装"
npm test  # テスト実行

# 問題なければ次のモジュール
./uzi checkpoint agent2 "feat: モジュールB実装"
npm test  # 再度テスト実行
```

## コマンドリファレンス

### 並列開発の正しい流れ
```bash
# 1. インターフェース定義をエージェントに作成させる
./uzi prompt "ブロック崩しゲームのモジュール構成とインターフェース定義を作成"

# 2. 統合テストを作成
./uzi prompt "定義されたインターフェースに基づいて統合テストを作成"

# 3. 並列実装（インターフェース定義を含める）
./uzi prompt "フロントエンドを実装。インターフェース定義：[定義内容]"
./uzi prompt "ゲームロジックを実装。インターフェース定義：[定義内容]"
./uzi prompt "状態管理を実装。インターフェース定義：[定義内容]"

# 4. 段階的マージ
./uzi checkpoint agent1 "feat: フロントエンド実装"
npm test
./uzi checkpoint agent2 "feat: ゲームロジック実装"
npm test
```

## 失敗例から学ぶ

### ❌ 悪い例（今回の失敗）
- インターフェース定義なしで並列開発
- 統合テストを後回し
- 一度に全モジュールをマージ

### ✅ 良い例（改善後）
- 事前にインターフェース定義
- 統合テストを最初に作成
- 段階的にモジュールを統合

## 関連ドキュメント

- [TDDワークフロー詳細（t_wada方式）](./docs/uzi-manager/01-tdd-workflow.md)
- [エージェント管理](./docs/uzi-manager/02-agent-management.md)
- [コマンドリファレンス](./docs/uzi-manager/06-command-reference.md)
